import drain from 'it-drain';
import { base32 } from 'multiformats/bases/base32';
import errCode from 'err-code';
function cidToKey(cid) {
    return '/' + base32.encode(cid.multihash.bytes).slice(1).toUpperCase();
}
function notFoundError(err) {
    err = err || new Error('Not Found');
    return errCode(err, 'ERR_NOT_FOUND');
}
// This Blockstore does not wrap a Datastore because the Key interface ineficiently encodes keys from
// bytes to string and back. The keys do respect the same format though so should remain compatible with
// future upgrades.
export class Cachestore {
    constructor(namespace) {
        this.namespace = namespace;
    }
    async open() {
        this.cache = await caches.open(this.namespace);
    }
    async close() { }
    put(key, val, options) {
        if (!this.cache) {
            throw new Error('Datastore needs to be opened.');
        }
        return this.cache.put(cidToKey(key), new Response(val));
    }
    async get(key, options) {
        if (!this.cache) {
            throw new Error('Datastore needs to be opened.');
        }
        const result = await this.cache.match(cidToKey(key));
        if (!result) {
            throw notFoundError();
        }
        const buf = await result.arrayBuffer();
        return new Uint8Array(buf);
    }
    async has(key, options) {
        if (!this.cache) {
            throw new Error('Datastore needs to be opened.');
        }
        try {
            await this.get(key);
        }
        catch (err) {
            if (err.code === 'ERR_NOT_FOUND')
                return false;
            throw err;
        }
        return true;
    }
    async delete(key, options) {
        if (!this.cache) {
            throw new Error('Datastore needs to be opened.');
        }
        await this.cache.delete(cidToKey(key));
    }
    async *putMany(source, options = {}) {
        for await (const { key, value } of source) {
            await this.put(key, value, options);
            yield { key, value };
        }
    }
    async *getMany(source, options = {}) {
        for await (const key of source) {
            yield this.get(key, options);
        }
    }
    async *deleteMany(source, options = {}) {
        for await (const key of source) {
            await this.delete(key, options);
            yield key;
        }
    }
    batch() {
        let puts = [];
        let dels = [];
        return {
            put(key, value) {
                puts.push({ key, value });
            },
            delete(key) {
                dels.push(key);
            },
            commit: async (options) => {
                await drain(this.putMany(puts, options));
                puts = [];
                await drain(this.deleteMany(dels, options));
                dels = [];
            },
        };
    }
    query(q, options) {
        throw new Error('query is not implemented');
    }
    queryKeys(q, options) {
        throw new Error('queryKeys is not implemented');
    }
}
//# sourceMappingURL=cachestore.js.map