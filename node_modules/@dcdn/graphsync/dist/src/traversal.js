import { CID } from "multiformats";
import { Block, encode as encodeBlock } from "multiformats/block";
import * as dagCBOR from "@ipld/dag-cbor";
import { sha256 } from "multiformats/hashes/sha2";
import { decode as decodePb } from "@ipld/dag-pb";
import { UnixFS } from "ipfs-unixfs";
export function decoderFor(cid) {
    switch (cid.code) {
        case 0x55:
            return null;
        case 0x70:
            return decodePb;
        case 0x71:
            return dagCBOR.decode;
        default:
            throw new Error("unsuported codec: " + cid.code);
    }
}
export async function blockFromStore(cid, bs) {
    const bytes = await bs.get(cid);
    const decode = decoderFor(cid);
    return new Block({ cid, bytes, value: decode ? decode(bytes) : bytes });
}
export class LinkSystem {
    constructor(store, reifiers) {
        this.reifiers = {};
        this.store = store;
        if (reifiers) {
            this.reifiers = reifiers;
        }
    }
    load(cid) {
        return blockFromStore(cid, this.store);
    }
    reifier(name) {
        return this.reifiers[name];
    }
    close() { }
}
export var Kind;
(function (Kind) {
    Kind["Invalid"] = "";
    Kind["Map"] = "{";
    Kind["List"] = "[";
    Kind["Null"] = "0";
    Kind["Bool"] = "b";
    Kind["Int"] = "i";
    Kind["Float"] = "f";
    Kind["String"] = "s";
    Kind["Bytes"] = "x";
    Kind["Link"] = "/";
})(Kind || (Kind = {}));
function isBytes(value) {
    if (value &&
        value.constructor &&
        value.constructor.isBuffer &&
        value.constructor.isBuffer.call(null, value)) {
        return true;
    }
    if (objectType(value) === "Uint8Array") {
        return true;
    }
    return false;
}
function objectType(value) {
    return Object.prototype.toString.call(value).slice(8, -1);
}
function is(value) {
    if (value === null) {
        return Kind.Null;
    }
    if (value === true || value === false) {
        return Kind.Bool;
    }
    const typeOf = typeof value;
    if (typeOf === "number") {
        if (value % 1 === 0) {
            return Kind.Int;
        }
        return Kind.Float;
    }
    if (typeOf === "string") {
        return Kind.String;
    }
    if (typeOf === "function") {
        return Kind.Invalid;
    }
    if (Array.isArray(value)) {
        return Kind.List;
    }
    if (isBytes(value)) {
        return Kind.Bytes;
    }
    if (objectType(value) === "Object") {
        return Kind.Map;
    }
    if (CID.asCID(value)) {
        return Kind.Link;
    }
    return Kind.Invalid;
}
// most requests use the same selectors so we memoize the blocks
// for improved performance
export const selToBlock = (function () {
    const memo = new Map();
    async function encodeSelToBlock(sel) {
        const m = memo.get(sel);
        if (m) {
            return m;
        }
        const blk = await encodeBlock({
            value: sel,
            codec: dagCBOR,
            hasher: sha256,
        });
        memo.set(sel, blk);
        return blk;
    }
    return encodeSelToBlock;
})();
export class Node {
    constructor(value) {
        this.kind = is(value);
        this.value = value;
    }
    lookupBySegment(seg) {
        const val = this.value[seg.value];
        if (val) {
            return val;
        }
        return null;
    }
}
export const allSelector = {
    R: {
        l: {
            none: {},
        },
        ":>": {
            a: {
                ">": {
                    "@": {},
                },
            },
        },
    },
};
export const entriesSelector = {
    R: {
        l: {
            depth: 1,
        },
        ":>": {
            a: {
                ">": {
                    "@": {},
                },
            },
        },
    },
};
class PathSegment {
    constructor(value) {
        this.value = value;
    }
    toString() {
        return this.value + "";
    }
}
export function parseContext() {
    let parentStack = [];
    return {
        pushParent(parent) {
            parentStack = [parent, ...parentStack];
            return this;
        },
        parseSelector(node) {
            const key = Object.keys(node)[0];
            switch (key) {
                case "R":
                    return this.parseExploreRecursive(node[key]);
                case "a":
                    return this.parseExploreAll(node[key]);
                case "@":
                    return this.parseExploreRecursiveEdge(node[key]);
                case "f":
                    return this.parseExploreFields(node[key]);
                case "~":
                    return this.parseExploreInterpretAs(node[key]);
                case ".":
                    return this.parseMatcher(node[key]);
                default:
                    throw new Error("unknown selector");
            }
        },
        parseExploreRecursive(node) {
            const limit = parseLimit(node["l"]);
            const erc = exploreRecursiveContext();
            const selector = this.pushParent(erc).parseSelector(node[":>"]);
            if (erc.edgesFound === 0) {
                throw new Error("selector spec parse rejected: ExploreRecursive must have at least one ExploreRecursiveEdge");
            }
            return new ExploreRecursive(selector, selector, limit);
        },
        parseExploreRecursiveEdge(node) {
            const recEdge = new ExploreRecursiveEdge();
            for (const parent of parentStack) {
                if (parent.link(recEdge)) {
                    return recEdge;
                }
            }
            throw new Error("selector spec parse rejected: ExploreRecursiveEdge must be beneath ExploreRecursive");
        },
        parseExploreAll(node) {
            const next = node[">"];
            const selector = this.parseSelector(next);
            return new ExploreAll(selector);
        },
        parseExploreFields(node) {
            const fields = node["f>"];
            const selections = {};
            const interests = [];
            for (const [key, value] of Object.entries(fields)) {
                interests.push(new PathSegment(key));
                selections[key] = this.parseSelector(value);
            }
            return new ExploreFields(selections, interests);
        },
        parseExploreInterpretAs(node) {
            const adl = node["as"];
            const next = node[">"];
            const selector = this.parseSelector(next);
            return new ExploreInterpretAs(adl, selector);
        },
        parseMatcher(node) {
            return new Matcher();
        },
    };
}
function exploreRecursiveContext() {
    let edgesFound = 0;
    return {
        link(s) {
            const ok = s instanceof ExploreRecursiveEdge;
            if (ok) {
                edgesFound++;
            }
            return ok;
        },
        get edgesFound() {
            return edgesFound;
        },
    };
}
var RecursionLimitMode;
(function (RecursionLimitMode) {
    RecursionLimitMode[RecursionLimitMode["None"] = 0] = "None";
    RecursionLimitMode[RecursionLimitMode["Depth"] = 1] = "Depth";
})(RecursionLimitMode || (RecursionLimitMode = {}));
export class ExploreAll {
    constructor(next) {
        this.next = next;
    }
    interests() {
        return [];
    }
    explore(node, path) {
        return this.next;
    }
    decide(node) {
        return false;
    }
}
export class ExploreRecursiveEdge {
    interests() {
        throw new Error("Traversed Explore Recursive Edge Node With No Parent");
    }
    explore(node, path) {
        throw new Error("Traversed Explore Recursive Edge Node With No Parent");
    }
    decide(node) {
        throw new Error("Traversed Explore Recursive Edge Node With No Parent");
    }
}
export class ExploreFields {
    constructor(selections, interests) {
        this.selections = selections;
        this._interests = interests;
    }
    interests() {
        return this._interests;
    }
    explore(node, path) {
        return this.selections[path.toString()] ?? null;
    }
    decide(node) {
        return false;
    }
}
export class ExploreInterpretAs {
    constructor(adl, next) {
        this.adl = adl;
        this.next = next;
    }
    interests() {
        return this.next.interests();
    }
    explore(node, path) {
        return this.next;
    }
    decide(node) {
        return false;
    }
}
export class Matcher {
    interests() {
        return [];
    }
    explore(node, path) {
        return null;
    }
    decide(node) {
        return true;
    }
}
export class ExploreRecursive {
    constructor(sequence, current, limit) {
        this.sequence = sequence;
        this.current = current;
        this.limit = limit;
    }
    interests() {
        return this.current.interests();
    }
    explore(node, path) {
        const nextSelector = this.current.explore(node, path);
        const limit = this.limit;
        if (nextSelector === null) {
            return null;
        }
        if (!this._hasRecursiveEdge(nextSelector)) {
            return new ExploreRecursive(this.sequence, nextSelector, limit);
        }
        switch (limit.mode) {
            case RecursionLimitMode.Depth:
                if (limit.depth < 2) {
                    return this._replaceRecursiveEdge(nextSelector, null);
                }
                return new ExploreRecursive(this.sequence, this._replaceRecursiveEdge(nextSelector, this.sequence), { mode: RecursionLimitMode.Depth, depth: limit.depth - 1 });
            case RecursionLimitMode.None:
                return new ExploreRecursive(this.sequence, this._replaceRecursiveEdge(nextSelector, this.sequence), limit);
        }
    }
    decide(node) {
        return this.current.decide(node);
    }
    _hasRecursiveEdge(nextSelector) {
        if (nextSelector instanceof ExploreRecursiveEdge) {
            return true;
        }
        // TODO: ExploreUnion
        return false;
    }
    _replaceRecursiveEdge(nextSelector, replacement) {
        if (nextSelector instanceof ExploreRecursiveEdge) {
            return replacement;
        }
        // TODO: ExploreUnion
        return nextSelector;
    }
}
function parseLimit(node) {
    const [key, val] = Object.entries(node)[0];
    switch (key) {
        case "depth":
            return { mode: RecursionLimitMode.Depth, depth: val };
        case "none":
            return { mode: RecursionLimitMode.None, depth: 0 };
        default:
            throw new Error("selector parse reject: " + key + " is not a known limit key");
    }
}
function segmentIterator(node) {
    if (Array.isArray(node)) {
        return arrayIterator(node);
    }
    return mapIterator(node);
}
function arrayIterator(node) {
    let i = 0;
    return {
        next() {
            if (i === node.length) {
                return {
                    pathSegment: null,
                    value: null,
                };
            }
            const index = i++;
            return {
                pathSegment: new PathSegment(index),
                value: node[index],
            };
        },
        done() {
            return i === node.length;
        },
    };
}
function mapIterator(node) {
    const keys = Object.keys(node);
    let i = 0;
    return {
        next() {
            if (i === keys.length) {
                return {
                    pathSegment: null,
                    value: null,
                };
            }
            const index = i++;
            return {
                pathSegment: new PathSegment(keys[index]),
                value: node[keys[index]],
            };
        },
        done() {
            return i === keys.length;
        },
    };
}
export function unixfsReifier(node, loader) {
    if (node.kind == Kind.Map &&
        node.value.Data &&
        node.value.Links?.length > 0) {
        try {
            const unixfs = UnixFS.unmarshal(node.value.Data);
            if (unixfs.isDirectory()) {
                const dir = {};
                for (const link of node.value.Links) {
                    dir[link.Name] = new Node(link.Hash);
                }
                return new Node(dir);
            }
        }
        catch (e) {
            return node;
        }
    }
    return node;
}
// walkBlocks execute a traversals only yielding blocks loaded along the way
export async function* walkBlocks(node, sel, source) {
    let nd = node;
    if (nd.kind === Kind.Link) {
        const blk = await source.load(nd.value);
        yield blk;
        nd = new Node(blk.value);
    }
    if (sel instanceof ExploreInterpretAs) {
        const reify = source.reifier(sel.adl);
        if (reify) {
            const rnd = reify(nd, source);
            const next = sel.explore(nd, new PathSegment(""));
            if (next) {
                sel = next;
            }
            nd = rnd;
        }
    }
    // if this block has no links we should be done
    switch (nd.kind) {
        case Kind.Map:
        case Kind.List:
            break;
        default:
            return;
    }
    // check if there's specific paths we should explore
    const attn = sel.interests();
    if (attn.length) {
        for (const ps of attn) {
            const value = nd.lookupBySegment(ps);
            if (value === null) {
                break;
            }
            const sNext = sel.explore(nd.value, ps);
            if (sNext !== null) {
                yield* walkBlocks(value, sNext, source);
            }
        }
    }
    else {
        // visit everything
        for (const itr = segmentIterator(nd.value); !itr.done();) {
            let { pathSegment, value } = itr.next();
            if (!pathSegment) {
                continue;
            }
            const sNext = sel.explore(nd.value, pathSegment);
            if (sNext !== null) {
                yield* walkBlocks(new Node(value), sNext, source);
            }
        }
    }
}
//# sourceMappingURL=traversal.js.map