import { CID } from "multiformats";
import { Block } from "multiformats/block";
import type { Store } from "interface-store";
export interface Blockstore extends Store<CID, Uint8Array> {
}
declare type Decoder = (data: Uint8Array) => any;
export declare function decoderFor(cid: CID): Decoder | null;
export declare function blockFromStore(cid: CID, bs: Blockstore): Promise<Block<any>>;
export declare class LinkSystem implements LinkLoader {
    store: Blockstore;
    reifiers: KnownReifiers;
    constructor(store: Blockstore, reifiers?: KnownReifiers);
    load(cid: CID): Promise<Block<any>>;
    reifier(name: string): NodeReifier | undefined;
    close(): void;
}
export declare enum Kind {
    Invalid = "",
    Map = "{",
    List = "[",
    Null = "0",
    Bool = "b",
    Int = "i",
    Float = "f",
    String = "s",
    Bytes = "x",
    Link = "/"
}
export declare const selToBlock: (sel: SelectorNode) => Promise<Block<SelectorNode>>;
export declare class Node {
    kind: Kind;
    value: any;
    constructor(value: any);
    lookupBySegment(seg: PathSegment): Node | null;
}
export declare type SelectorNode = {
    "."?: {
        "["?: number;
        "]"?: number;
    };
    a?: {
        ">": SelectorNode;
    };
    f?: {
        "f>"?: {
            [key: string]: SelectorNode;
        };
    };
    i?: {
        i?: number;
        ">"?: SelectorNode;
    };
    r?: {
        "^"?: number;
        $?: number;
        ">"?: SelectorNode;
    };
    R?: {
        l: LimitNode;
        ":>"?: SelectorNode;
    };
    "~"?: {
        as: string;
        ">": SelectorNode;
    };
    "|"?: SelectorNode;
    "&"?: SelectorNode;
    "@"?: SelectorNode;
    "!"?: SelectorNode;
};
declare type LimitNode = {
    none?: {};
    depth?: number;
};
export declare const allSelector: SelectorNode;
export declare const entriesSelector: SelectorNode;
declare class PathSegment {
    value: string | number;
    constructor(value: string | number);
    toString(): string;
}
export interface Selector {
    interests(): PathSegment[];
    explore(node: any, path: PathSegment): Selector | null;
    decide(node: any): boolean;
}
interface ParsedParent {
    link(s: Selector): boolean;
}
export declare function parseContext(): {
    pushParent(parent: ParsedParent): any;
    parseSelector(node: SelectorNode): Selector;
    parseExploreRecursive(node: any): Selector;
    parseExploreRecursiveEdge(node: any): Selector;
    parseExploreAll(node: any): Selector;
    parseExploreFields(node: any): Selector;
    parseExploreInterpretAs(node: any): Selector;
    parseMatcher(node: any): Selector;
};
declare enum RecursionLimitMode {
    None = 0,
    Depth = 1
}
declare type RecursionLimit = {
    mode: RecursionLimitMode;
    depth: number;
};
export declare class ExploreAll implements Selector {
    next: Selector;
    constructor(next: Selector);
    interests(): PathSegment[];
    explore(node: any, path: PathSegment): Selector | null;
    decide(node: any): boolean;
}
export declare class ExploreRecursiveEdge implements Selector {
    interests(): PathSegment[];
    explore(node: any, path: PathSegment): Selector | null;
    decide(node: any): boolean;
}
export declare class ExploreFields implements Selector {
    selections: {
        [key: string]: Selector;
    };
    _interests: PathSegment[];
    constructor(selections: {
        [key: string]: Selector;
    }, interests: PathSegment[]);
    interests(): PathSegment[];
    explore(node: any, path: PathSegment): Selector | null;
    decide(node: any): boolean;
}
export declare class ExploreInterpretAs implements Selector {
    next: Selector;
    adl: string;
    constructor(adl: string, next: Selector);
    interests(): PathSegment[];
    explore(node: any, path: PathSegment): Selector | null;
    decide(node: any): boolean;
}
export declare class Matcher implements Selector {
    interests(): PathSegment[];
    explore(node: any, path: PathSegment): Selector | null;
    decide(node: any): boolean;
}
export declare class ExploreRecursive implements Selector {
    sequence: Selector;
    current: Selector;
    limit: RecursionLimit;
    constructor(sequence: Selector, current: Selector, limit: RecursionLimit);
    interests(): PathSegment[];
    explore(node: any, path: PathSegment): Selector | null;
    decide(node: any): boolean;
    _hasRecursiveEdge(nextSelector: Selector): boolean;
    _replaceRecursiveEdge(nextSelector: Selector, replacement: null): null;
    _replaceRecursiveEdge(nextSelector: Selector, replacement: Selector): Selector;
}
export declare type NodeReifier = (node: Node, loader: LinkLoader) => Node;
export declare type KnownReifiers = {
    [key: string]: NodeReifier;
};
export declare function unixfsReifier(node: Node, loader: LinkLoader): Node;
export interface LinkLoader {
    load(cid: CID): Promise<Block<any>>;
    reifier(name: string): NodeReifier | undefined;
    close(): void;
}
export declare function walkBlocks(node: Node, sel: Selector, source: LinkLoader): AsyncIterable<Block<any>>;
export {};
//# sourceMappingURL=traversal.d.ts.map