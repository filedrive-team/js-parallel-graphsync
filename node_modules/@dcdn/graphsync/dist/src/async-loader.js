import { blockFromStore, } from "./traversal";
// AsyncLoader waits for a block to be anounced if it is not available in the blockstore
export class AsyncLoader {
    constructor(store, tracker, waitNotify) {
        // pending are block that have been pushed but not yet loaded
        this.pending = new Map();
        // loaded is a set of string CIDs for content that was loaded.
        // content included in the set will be flushed to the blockstore.
        this.loaded = new Set();
        this.pullQueue = new Map();
        this.reifiers = {};
        this.notifyWaiting = false;
        this.store = store;
        this.tracker = tracker;
        if (waitNotify) {
            this.setWaitNotify(waitNotify);
        }
    }
    async load(cid) {
        const k = cid.toString();
        try {
            let blk = this.pending.get(k);
            if (blk) {
                this.flush(blk);
                return blk;
            }
            blk = await blockFromStore(cid, this.store);
            return blk;
        }
        catch (e) {
            const blk = await this.waitForBlock(cid);
            this.flush(blk);
            return blk;
        }
        finally {
            this.loaded.add(k);
        }
    }
    // waitForBlock will queue up a promise that will get resolved once a block
    // is pushed to the loader.
    async waitForBlock(cid) {
        const block = this.pending.get(cid.toString());
        if (block) {
            return block;
        }
        if (this.loaded.has(cid.toString())) {
            return blockFromStore(cid, this.store);
        }
        if (this.waitNotify && this.notifyWaiting) {
            this.waitNotify(cid);
        }
        return new Promise((resolve, reject) => {
            this.pullQueue.set(cid.toString(), (this.pullQueue.get(cid.toString()) ?? []).concat({ resolve, reject }));
        });
    }
    // these are trusted blocks and don't need to be verified
    push(block) {
        const k = block.cid.toString();
        const pending = this.pullQueue.get(k);
        if (pending) {
            pending.forEach((p) => p.resolve(block));
        }
        else {
            this.pending.set(k, block);
        }
    }
    // move a pending block to the blockstore.
    flush(blk) {
        if (!this.loaded.has(blk.cid.toString())) {
            this.tracker?.(blk);
            this.store
                .put(blk.cid, new Uint8Array(blk.bytes))
                .then(() => this.pending.delete(blk.cid.toString()));
        }
    }
    reifier(name) {
        return this.reifiers[name];
    }
    // cleanup any block in memory
    close() {
        this.pending = new Map();
    }
    setWaitNotify(cb) {
        this.waitNotify = cb;
        this.notifyWaiting = true;
    }
}
//# sourceMappingURL=async-loader.js.map