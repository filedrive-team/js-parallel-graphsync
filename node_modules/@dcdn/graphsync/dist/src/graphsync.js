import lp from "it-length-prefixed";
import { EventEmitter } from "events";
import { v4 as uuidv4, stringify as uuidStringify } from "uuid";
import { pipe } from "it-pipe";
import { AsyncLoader } from "./async-loader";
// @ts-ignore (no types)
import "varint-decoder";
import { sha256 } from "multiformats/hashes/sha2";
import drain from "it-drain";
import { PROTOCOL, decodeBlock, decodeMessage, newRequest, } from "./messages";
import { Node, walkBlocks, parseContext, unixfsReifier } from "./traversal";
import { responseBuilder } from "./response-builder";
export class GraphSync extends EventEmitter {
    constructor(net, blocks) {
        super();
        this.started = false;
        this.hashers = {
            [sha256.code]: sha256,
        };
        this.requests = new Map();
        this.network = net;
        this.blocks = blocks;
    }
    start() {
        if (!this.started) {
            this.network.handle(PROTOCOL, this._handler.bind(this));
            this.started = true;
        }
    }
    stop() {
        this.started = false;
        this.network.unhandle(PROTOCOL);
    }
    // creates a new request for the given link and selector
    request(link, sel) {
        const id = uuidv4();
        const request = new Request(id, link, sel, this.network, this.blocks);
        this.requests.set(id, request);
        return request;
    }
    _loadBlocksForRequests(gblocks, reqids) {
        for (const block of gblocks) {
            decodeBlock(block, this.hashers)
                .then((blk) => reqids.forEach((id) => {
                const req = this.requests.get(id);
                if (req) {
                    req.loader.push(blk);
                }
            }))
                .catch((err) => {
                console.log(err);
            });
        }
    }
    _handleResponse(resp) {
        const req = this.requests.get(uuidStringify(resp.reqid));
        if (req) {
            req.incomingResponseHook(resp);
        }
    }
    async _handleRequest(peer, req) {
        try {
            const { stream } = await this.network.dialProtocol(peer, PROTOCOL);
            await pipe(responseBuilder(req, this.blocks), lp.encode(), stream);
            this.emit("responseCompleted", { id: req.id, root: req.root, peer });
        }
        catch (e) {
            this.emit("networkErrorListener", {
                id: req.id,
                root: req.root,
                peer,
                error: e,
            });
        }
    }
    async _handler(props) {
        const source = props.stream.source;
        for await (const chunk of lp.decode()(source)) {
            const msg = decodeMessage(chunk.slice());
            if (msg.blk && msg.rsp) {
                this._loadBlocksForRequests(msg.blk, msg.rsp.map((resp) => uuidStringify(resp.reqid)));
            }
            if (msg.rsp) {
                msg.rsp.forEach((resp) => this._handleResponse(resp));
            }
            if (msg.req) {
                msg.req.forEach((req) => this._handleRequest(props.connection.remotePeer, req));
            }
        }
    }
}
export class Request extends EventEmitter {
    constructor(id, root, sel, dialer, blocks) {
        super();
        this.reifiers = {
            unixfs: unixfsReifier,
        };
        this.id = id;
        this.dialer = dialer;
        this.root = root;
        this.selector = sel;
        this.loader = new AsyncLoader(blocks, this.incomingBlockHook.bind(this));
    }
    open(peer, extensions) {
        return new Promise((resolve, reject) => {
            this.loader.setWaitNotify(async () => {
                this.loader.notifyWaiting = false;
                try {
                    const { stream } = await this.dialer.dialProtocol(peer, PROTOCOL);
                    pipe([newRequest(this.id, this.root, this.selector, extensions)], stream);
                    resolve();
                }
                catch (e) {
                    reject(e);
                }
            });
        });
    }
    async drain() {
        await drain(walkBlocks(new Node(this.root), parseContext().parseSelector(this.selector), this));
    }
    reifier(name) {
        return this.reifiers[name];
    }
    // TODO
    close() { }
    load(link) {
        return this.loader.load(link);
    }
    incomingBlockHook(block) {
        this.emit("incomingBlock", { link: block.cid, size: block.bytes.length });
    }
    incomingResponseHook(resp) {
        this.emit("incomingResponse", resp);
    }
}
//# sourceMappingURL=graphsync.js.map